#define F_CPU 8000000UL
//main avr libraries
#include "avr/io.h"
#include "util/delay.h"

#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/FreeRTOS.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/task.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/croutine.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/FreeRTOSConfig.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/portable.h"

#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/list.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/macros.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/mpu_wrappers.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/portmacro.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/projdefs.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/queue.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/semphr.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/StackMacros.h"
#include "../CSWC_PLTF_BSW_ATMEGA32/Free_RTOS/timers.h"

/* Define all the tasks */
static void ledBlinkingtask1(void* pvParameters);
static void CheckSwitchtask2(void* pvParameters);

/*Define Semaphore*/
xSemaphoreHandle semaphore1 = NULL;

int main(void) {
	/* Call FreeRTOS APIs to create tasks, all tasks has the same priority "1" with the
	same stack size*/
	xTaskCreate( ledBlinkingtask1, ( signed char * ) "LED",
			configMINIMAL_STACK_SIZE, NULL, 1, NULL );
	xTaskCreate( CheckSwitchtask2, ( signed char * ) "Switch",
			configMINIMAL_STACK_SIZE, NULL, 2, NULL );


	vSemaphoreCreateBinary( semaphore1);

	// Start the RTOS kernel
	vTaskStartScheduler();
	/* Do nothing here and just run infinite loop */
	while(1);
	return 0;
}

static void ledBlinkingtask1(void* pvParameters)
{
	/* Define all variables related to ledBlinkingtask1*/
	const uint16_t blinkDelay = 500 ;
	/* make PB0 work as output*/
	DDRB |= (1<<PB0);
	/* Start the infinite task 1 loop */
	while (1)
	{
		if( xSemaphoreTake( semaphore1, ( portTickType ) 10 ) == pdTRUE )
		{
			PORTB ^= (1<<PB0); //toggle PB0
		}
		//vTaskDelay(blinkDelay); //wait some time
	}
}

static void CheckSwitchtask2(void* pvParameters)
{
	/* Check the Switch every 200 msec*/
	const uint16_t switchDelay = 200 ;

	/*make PB1 work as input*/
	DDRB &=~(1<<PB1);
	/*pull-up activation of PB1*/
	PORTB |=(1<<PB1);

	vSemaphoreCreateBinary( semaphore1);

	while (1)
	{
		if(!(((PINB) >> (PB1)) & 0x01))
		{
			xSemaphoreGive( semaphore1);
		}
		vTaskDelay(switchDelay); //wait some time
	}
}

